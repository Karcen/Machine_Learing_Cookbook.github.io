<!DOCTYPE html>
<html lang="zh-CN" data-theme="light"> <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ML Visual Lab: æœºå™¨å­¦ä¹ å¯è§†åŒ–å…¨è§£</title>
    
    <script>
    window.MathJax = {
      tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
      svg: { fontCache: 'global' },
      startup: { typeset: false }
    };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <style>
        :root {
            /* æµ…è‰²æ¨¡å¼ (é»˜è®¤) */
            --bg-body: #f8fafc;
            --bg-sidebar: #ffffff;
            --bg-card: #ffffff;
            --text-main: #0f172a;
            --text-sub: #64748b;
            --accent: #4f46e5; /* Indigo */
            --border: #e2e8f0;
            --code-bg: #1e293b; /* ä»£ç å—å§‹ç»ˆæ·±è‰²æ›´å¥½çœ‹ */
            --math-bg: #f1f5f9;
            --chart-grid: #e2e8f0;
            --chart-line: #4f46e5;
        }

        [data-theme="dark"] {
            /* æ·±è‰²æ¨¡å¼ */
            --bg-body: #0f172a;
            --bg-sidebar: #1e293b;
            --bg-card: #1e293b;
            --text-main: #f1f5f9;
            --text-sub: #94a3b8;
            --accent: #38bdf8; /* Sky Blue */
            --border: #334155;
            --code-bg: #020617;
            --math-bg: rgba(0,0,0,0.2);
            --chart-grid: #334155;
            --chart-line: #38bdf8;
        }

        body { font-family: 'Inter', system-ui, sans-serif; background: var(--bg-body); color: var(--text-main); margin: 0; display: flex; height: 100vh; overflow: hidden; transition: 0.3s; }

        /* Sidebar */
        nav { width: 260px; background: var(--bg-sidebar); border-right: 1px solid var(--border); display: flex; flex-direction: column; flex-shrink: 0; }
        .nav-header { padding: 20px; border-bottom: 1px solid var(--border); }
        .nav-header h1 { margin: 0; font-size: 1.2rem; color: var(--accent); font-weight: 800; }
        .nav-content { overflow-y: auto; flex-grow: 1; padding-top: 10px; }
        
        .nav-group { padding: 15px 20px 5px; font-size: 0.75rem; color: var(--text-sub); font-weight: bold; text-transform: uppercase; letter-spacing: 0.5px; }
        .nav-item { padding: 10px 20px; cursor: pointer; border-left: 3px solid transparent; color: var(--text-sub); font-size: 0.9rem; transition: 0.2s; display: flex; align-items: center; gap: 8px; }
        .nav-item:hover { background: rgba(128,128,128,0.05); color: var(--text-main); }
        .nav-item.active { border-left-color: var(--accent); background: rgba(var(--accent), 0.1); color: var(--text-main); font-weight: 600; }

        .author { padding: 15px; font-size: 0.8rem; text-align: center; color: var(--text-sub); border-top: 1px solid var(--border); }

        /* Main */
        main { flex-grow: 1; display: flex; flex-direction: column; overflow-y: auto; position: relative; }
        .header-bar { padding: 15px 30px; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; background: var(--bg-body); position: sticky; top: 0; z-index: 10; }
        .theme-btn { background: transparent; border: 1px solid var(--border); padding: 6px 12px; border-radius: 6px; cursor: pointer; color: var(--text-main); }

        .container { padding: 30px; max-width: 1100px; margin: 0 auto; width: 100%; box-sizing: border-box; }
        
        /* Components */
        .card { background: var(--bg-card); border: 1px solid var(--border); border-radius: 10px; padding: 20px; margin-bottom: 20px; box-shadow: 0 2px 10px rgba(0,0,0,0.03); }
        
        .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        
        .canvas-wrapper { height: 300px; background: var(--bg-body); border: 1px solid var(--border); border-radius: 8px; position: relative; overflow: hidden; cursor: crosshair; }
        canvas { width: 100%; height: 100%; display: block; }
        
        .math-box { background: var(--math-bg); padding: 15px; border-radius: 6px; border-left: 4px solid var(--accent); margin: 15px 0; overflow-x: auto; }
        pre { background: var(--code-bg); color: #a5b4fc; padding: 15px; border-radius: 6px; overflow-x: auto; font-family: monospace; font-size: 0.9rem; }

        /* Controls & Badges */
        .controls { display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 15px; align-items: center; }
        button.btn { background: var(--accent); color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: 600; transition: 0.2s; }
        button.btn:hover { opacity: 0.9; transform: translateY(-1px); }
        button.btn-outline { background: transparent; border: 1px solid var(--border); color: var(--text-sub); padding: 8px 16px; border-radius: 6px; cursor: pointer; }
        
        .badge { padding: 4px 10px; border-radius: 20px; font-size: 0.8rem; font-weight: bold; }
        .bg-green { background: rgba(34, 197, 94, 0.15); color: #16a34a; }
        .bg-red { background: rgba(239, 68, 68, 0.15); color: #dc2626; }
        .bg-gray { background: rgba(100,116,139, 0.15); color: #64748b; }

        .legend { display: flex; gap: 15px; margin-bottom: 10px; font-size: 0.85rem; color: var(--text-sub); }
        .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; margin-right: 5px; }

    </style>
</head>
<body>

<nav>
    <div class="nav-header">
        <h1>ML Visual Lab</h1>
    </div>
    <div class="nav-content">
        <div class="nav-group">æ ¸å¿ƒæ¦‚å¿µ (Core)</div>
        <div class="nav-item active" onclick="router.load('concept_loss')">ğŸ“‰ æŸå¤±ä¸è¿‡æ‹Ÿåˆ</div>
        <div class="nav-item" onclick="router.load('concept_reg')">ğŸ›¡ï¸ æ­£åˆ™åŒ–</div>

        <div class="nav-group">äº¤äº’å®éªŒå®¤ (Interactive)</div>
        <div class="nav-item" onclick="router.load('lab_linear')">ğŸ“ çº¿æ€§å›å½’ (Linear)</div>
        <div class="nav-item" onclick="router.load('lab_knn')">ğŸ”´ KNN åˆ†ç±»</div>
        <div class="nav-item" onclick="router.load('lab_kmeans')">ğŸ§© K-Means èšç±»</div>
    </div>
    <div class="author">ç”± Karcen Zheng åˆ¶ä½œ</div>
</nav>

<main>
    <div class="header-bar">
        <h2 id="pageTitle" style="margin:0; font-size:1.1rem; color:var(--text-main)"></h2>
        <button class="theme-btn" onclick="toggleTheme()">ğŸŒ— åˆ‡æ¢æ¨¡å¼</button>
    </div>
    <div id="app" class="container"></div>
</main>

<script>
// ==========================================
// 1. é¡µé¢å†…å®¹é…ç½®
// ==========================================
const pages = {
    // --- 1. Loss & Overfitting ---
    'concept_loss': {
        title: 'Loss Function & Overfitting',
        content: `
            <div class="card">
                <p>è¿™æ˜¯æœºå™¨å­¦ä¹ ä¸­æœ€é‡è¦çš„ä¸€è¯¾ã€‚è§‚å¯Ÿæ¨¡å‹åœ¨è®­ç»ƒè¿‡ç¨‹ä¸­ï¼Œå¦‚ä½•ä»â€œæ²¡å­¦ä¼šâ€åˆ°â€œå­¦ä¼šâ€ï¼Œæœ€åå˜æˆâ€œæ­»è®°ç¡¬èƒŒâ€ã€‚</p>
                <div class="controls">
                    <button class="btn" onclick="simLoss.start()">â–¶ å¼€å§‹è®­ç»ƒ</button>
                    <button class="btn-outline" onclick="simLoss.step()">ğŸ‘£ å•æ­¥æ‰§è¡Œ</button>
                    <button class="btn-outline" onclick="simLoss.reset()">ğŸ”„ é‡ç½®</button>
                    <div id="lossStatus" class="badge bg-gray" style="margin-left:auto;">Epoch: 0 | ç­‰å¾…å¼€å§‹</div>
                </div>
                
                <div class="grid-2">
                    <div>
                        <div class="legend">
                            <span><span class="dot" style="background:var(--text-main)"></span>æ•°æ®ç‚¹</span>
                            <span><span class="dot" style="background:var(--accent)"></span>æ¨¡å‹æ‹Ÿåˆçº¿</span>
                        </div>
                        <div class="canvas-wrapper"><canvas id="cvs_fit"></canvas></div>
                    </div>
                    <div>
                        <div class="legend">
                            <span><span class="dot" style="background:#22c55e"></span>Train Loss (ç»ƒä¹ é¢˜)</span>
                            <span><span class="dot" style="background:#ef4444"></span>Val Loss (è€ƒè¯•é¢˜)</span>
                        </div>
                        <div class="canvas-wrapper"><canvas id="cvs_loss"></canvas></div>
                    </div>
                </div>
            </div>

            <div class="grid-2">
                <div class="math-box">
                    <b>Loss (å‡æ–¹è¯¯å·®):</b> $$ J(\\theta) = \\frac{1}{m} \\sum (y - \\hat{y})^2 $$
                </div>
                <div class="card" style="margin:0; padding:15px; font-size:0.9rem;">
                    <b>ğŸ’¡ è§‚å¯ŸæŒ‡å—ï¼š</b><br>
                    1. <b>å‰ 20 è½®</b>ï¼šç»¿çº¿çº¢çº¿ä¸€èµ·é™ï¼ˆæ­£å¸¸å­¦ä¹ ï¼‰ã€‚<br>
                    2. <b>30 è½®å</b>ï¼šç»¿çº¿ç»§ç»­é™ï¼Œä½†çº¢çº¿<b>åå¼¹</b>ï¼ˆè¿‡æ‹Ÿåˆï¼‰ã€‚<br>
                    3. å·¦ä¾§è“çº¿ä¼šå˜å¾—æå…¶æ‰­æ›²ï¼Œè¯•å›¾ç©¿è¿‡æ‰€æœ‰å™ªå£°ç‚¹ã€‚
                </div>
            </div>
        `,
        init: () => simLoss.init()
    },

    // --- 2. Regularization ---
    'concept_reg': {
        title: 'Regularization (æ­£åˆ™åŒ–)',
        content: `
            <div class="card">
                <p>å¦‚ä½•æ²»æ„ˆè¿‡æ‹Ÿåˆï¼ŸåŠ ä¸€ä¸ªâ€œæƒ©ç½šé¡¹â€ã€‚æ‹–åŠ¨æ»‘å—ï¼Œçœ‹æ­£åˆ™åŒ–å¦‚ä½•æŠŠæ‰­æ›²çš„çº¿â€œæ‹‰ç›´â€ã€‚</p>
                <div class="controls">
                    <label>å¤šé¡¹å¼æ¬¡æ•° (å¤æ‚åº¦): <input type="range" id="regDegree" min="1" max="15" value="12" oninput="simReg.draw()"></label>
                </div>
                <div class="controls">
                    <label>Lambda (æƒ©ç½šåŠ›åº¦ $\\lambda$): <input type="range" id="regLambda" min="0" max="100" value="0" oninput="simReg.draw()"></label>
                    <span id="lambdaDisp" style="font-weight:bold; color:var(--accent); width:100px;">0 (æ— æƒ©ç½š)</span>
                </div>
                <div class="canvas-wrapper" style="height:350px;"><canvas id="cvs_reg"></canvas></div>
            </div>
            <div class="math-box">
                $$ J(\\theta) = Loss + \\underbrace{\\lambda \\sum \\theta_j^2}_{L2 æ­£åˆ™åŒ–é¡¹} $$
            </div>
        `,
        init: () => simReg.init()
    },

    // --- 3. Linear Regression (Interactive) ---
    'lab_linear': {
        title: 'Interactive Linear Regression',
        content: `
            <div class="card">
                <div class="controls">
                    <span class="badge bg-green">æ“ä½œæŒ‡å—</span>
                    <span style="font-size:0.9rem; color:var(--text-sub)">åœ¨ä¸‹æ–¹ç©ºç™½å¤„<b>ç‚¹å‡»é¼ æ ‡</b>æ·»åŠ æ•°æ®ç‚¹ï¼Œæ¨¡å‹ä¼šè‡ªåŠ¨æ‹Ÿåˆç›´çº¿ã€‚</span>
                    <button class="btn-outline" style="margin-left:auto;" onclick="simLinear.clear()">ğŸ—‘ï¸ æ¸…ç©ºç”»å¸ƒ</button>
                </div>
                <div class="canvas-wrapper" style="height:400px;" onmousedown="simLinear.addPoint(event)">
                    <canvas id="cvs_linear"></canvas>
                </div>
            </div>
            <div class="math-box">
                æœ€å°äºŒä¹˜æ³•è§£æè§£ (Closed Form): $$ w = (X^T X)^{-1} X^T y $$
            </div>
        `,
        init: () => simLinear.init()
    },

    // --- 4. KNN (Interactive) ---
    'lab_knn': {
        title: 'K-Nearest Neighbors (KNN)',
        content: `
            <div class="card">
                <div class="controls">
                    <span class="badge bg-green">æ“ä½œæŒ‡å—</span>
                    <span style="font-size:0.9rem; color:var(--text-sub)"><b>å·¦é”®</b>æ·»åŠ çº¢è‰²ç±»åˆ«ï¼Œ<b>å³é”®</b>æ·»åŠ è“è‰²ç±»åˆ«ã€‚</span>
                    <label style="margin-left:20px;">Kå€¼: <input type="number" id="knnK" value="3" min="1" max="9" style="width:50px;" onchange="simKNN.draw()"></label>
                    <button class="btn-outline" style="margin-left:auto;" onclick="simKNN.clear()">ğŸ—‘ï¸ æ¸…ç©º</button>
                </div>
                <div class="canvas-wrapper" style="height:400px;" onmousedown="simKNN.addPoint(event)" oncontextmenu="event.preventDefault(); simKNN.addPoint(event, 1)">
                    <canvas id="cvs_knn"></canvas>
                </div>
                <p style="font-size:0.8rem; color:var(--text-sub); text-align:center;">èƒŒæ™¯é¢œè‰²ä»£è¡¨æ¨¡å‹çš„å†³ç­–è¾¹ç•Œ (Decision Boundary)</p>
            </div>
        `,
        init: () => simKNN.init()
    },

    // --- 5. K-Means (Interactive) ---
    'lab_kmeans': {
        title: 'K-Means Clustering',
        content: `
            <div class="card">
                <div class="controls">
                    <span class="badge bg-green">æ­¥éª¤ 1</span>
                    <span>ç‚¹å‡»ç”»å¸ƒæ·»åŠ æ•°æ®ç‚¹</span>
                    <span class="badge bg-red" style="margin-left:10px;">æ­¥éª¤ 2</span>
                    <span>ç‚¹å‡»â€œè¿­ä»£â€æŒ‰é’®</span>
                    
                    <button class="btn" style="margin-left:auto;" onclick="simKMeans.step()">ğŸ‘£ è¿­ä»£ä¸€æ­¥ (Step)</button>
                    <button class="btn-outline" onclick="simKMeans.clear()">ğŸ—‘ï¸ é‡ç½®</button>
                </div>
                <div class="canvas-wrapper" style="height:400px;" onmousedown="simKMeans.addPoint(event)">
                    <canvas id="cvs_kmeans"></canvas>
                </div>
            </div>
        `,
        init: () => simKMeans.init()
    }
};

// ==========================================
// 2. æ¨¡æ‹Ÿå¼•æ“ (Engines)
// ==========================================

// --- Engine 1: Loss & Overfitting (Slowed Down) ---
const simLoss = {
    epoch: 0,
    timer: null,
    data: [],
    trainLoss: [],
    valLoss: [],
    ctxFit: null,
    ctxLoss: null,
    
    init: function() {
        this.reset();
        this.ctxFit = setupCanvas('cvs_fit');
        this.ctxLoss = setupCanvas('cvs_loss');
        this.draw();
    },
    
    reset: function() {
        clearInterval(this.timer);
        this.timer = null;
        this.epoch = 0;
        this.trainLoss = [];
        this.valLoss = [];
        // ç”Ÿæˆæ•°æ®
        this.data = [];
        for(let x=-10; x<=10; x+=1.5) {
            this.data.push({x:x, y: 0.3*x*x + (Math.random()-0.5)*30});
        }
        updateStatus('lossStatus', 'Epoch: 0 | å‡†å¤‡å°±ç»ª', 'bg-gray');
        if(this.ctxFit) this.draw();
    },
    
    start: function() {
        if(this.timer) return;
        // é™ä½é€Ÿåº¦ï¼šæ¯ 150ms èµ°ä¸€æ­¥ (ä¹‹å‰æ˜¯æ¯å¸§ 16ms)
        this.timer = setInterval(() => this.step(true), 150);
    },
    
    step: function(auto=false) {
        if(this.epoch >= 60) {
            clearInterval(this.timer);
            this.timer = null;
            return;
        }
        this.epoch++;
        
        // æ¨¡æ‹Ÿ Loss é€»è¾‘
        const base = Math.exp(-this.epoch * 0.1) * 80;
        let tl = base + Math.random()*2;
        let vl = base + 15 + Math.random()*5;
        
        // è¿‡æ‹Ÿåˆç‚¹
        if(this.epoch > 25) {
            tl -= (this.epoch-25)*0.5; // Train ç»§ç»­é™
            vl += (this.epoch-25)*1.2; // Val å‡é«˜
            updateStatus('lossStatus', `Epoch: ${this.epoch} | âš ï¸ è¿‡æ‹Ÿåˆä¸­!`, 'bg-red');
        } else {
            updateStatus('lossStatus', `Epoch: ${this.epoch} | å­¦ä¹ ä¸­...`, 'bg-green');
        }
        
        if(tl < 0) tl = 0;
        this.trainLoss.push(tl);
        this.valLoss.push(vl);
        this.draw();
        
        if(!auto) clearInterval(this.timer); // å¦‚æœæ˜¯æ‰‹åŠ¨ç‚¹å‡»å•æ­¥ï¼Œæ¸…é™¤è‡ªåŠ¨è®¡æ—¶å™¨
    },
    
    draw: function() {
        if(!this.ctxFit) return;
        const w = this.ctxFit.canvas.width;
        const h = this.ctxFit.canvas.height;
        
        // 1. Draw Fit
        this.ctxFit.clearRect(0,0,w,h);
        // Points
        this.ctxFit.fillStyle = getCSS('--text-main');
        this.data.forEach(p => {
            drawCircle(this.ctxFit, mapX(p.x, w), mapY(p.y, h), 4);
        });
        // Line
        this.ctxFit.strokeStyle = getCSS('--accent');
        this.ctxFit.lineWidth = 3;
        this.ctxFit.beginPath();
        for(let x=-10; x<=10; x+=0.5) {
            let y_pred;
            if(this.epoch < 5) y_pred = 40; // Underfit
            else if(this.epoch < 25) y_pred = 0.3*x*x; // Good fit
            else {
                // Wiggly Overfit
                y_pred = 0.3*x*x + Math.sin(x*2 + this.epoch)*10 * ((this.epoch-20)/40);
            }
            const px = mapX(x, w);
            const py = mapY(y_pred, h);
            if(x===-10) this.ctxFit.moveTo(px, py); else this.ctxFit.lineTo(px, py);
        }
        this.ctxFit.stroke();
        
        // 2. Draw Loss
        const ctxL = this.ctxLoss;
        ctxL.clearRect(0,0,w,h);
        drawGrid(ctxL, w, h);
        
        drawChartLine(ctxL, this.trainLoss, '#22c55e', 100, w, h);
        drawChartLine(ctxL, this.valLoss, '#ef4444', 100, w, h);
    }
};

// --- Engine 2: Regularization ---
const simReg = {
    ctx: null,
    points: [],
    
    init: function() {
        this.ctx = setupCanvas('cvs_reg');
        this.points = [];
        for(let i=0; i<15; i++) {
            this.points.push({x: i/14, y: 0.5 + (Math.random()-0.5)*0.3});
        }
        this.draw();
    },
    
    draw: function() {
        if(!this.ctx) return;
        const w = this.ctx.canvas.width;
        const h = this.ctx.canvas.height;
        const lambda = parseInt(document.getElementById('regLambda').value);
        const degree = parseInt(document.getElementById('regDegree').value);
        
        document.getElementById('lambdaDisp').innerText = lambda > 0 ? `Î» = ${lambda}` : "0 (è¿‡æ‹Ÿåˆ)";
        
        this.ctx.clearRect(0,0,w,h);
        
        // Points
        this.ctx.fillStyle = getCSS('--text-main');
        this.points.forEach(p => {
            drawCircle(this.ctx, p.x*w, h - p.y*h, 5);
        });
        
        // Curve
        this.ctx.strokeStyle = lambda > 50 ? '#22c55e' : (lambda > 10 ? '#38bdf8' : '#ef4444');
        this.ctx.lineWidth = 3;
        this.ctx.beginPath();
        
        for(let x=0; x<=1; x+=0.01) {
            let y = 0.5;
            // æ¨¡æ‹Ÿç®—æ³•ï¼šLambda è¶Šå¤§ï¼Œæ ¸å‡½æ•°çš„å¸¦å®½(bandwidth)è¶Šå¤§ï¼Œæ›²çº¿è¶Šå¹³æ»‘
            const smooth = 1 + lambda * 0.5; 
            const wiggliness = degree * 20; 
            
            for(let p of this.points) {
                const dist = Math.abs(x - p.x);
                // æ²¡æœ‰æ­£åˆ™åŒ–æ—¶ï¼Œé«˜æ¬¡å¤šé¡¹å¼å…è®¸åœ¨æçŸ­è·ç¦»å†…å‰§çƒˆå˜åŒ–
                // åŠ äº†æ­£åˆ™åŒ–ï¼Œå¼ºè¡Œæ‹‰å¹³å˜åŒ–
                const influence = Math.exp(-dist*dist * (wiggliness / smooth));
                y += (p.y - 0.5) * influence * 0.8;
            }
            if(x===0) this.ctx.moveTo(x*w, h-y*h); else this.ctx.lineTo(x*w, h-y*h);
        }
        this.ctx.stroke();
    }
};

// --- Engine 3: Linear Regression ---
const simLinear = {
    ctx: null,
    points: [],
    
    init: function() {
        this.ctx = setupCanvas('cvs_linear');
        this.points = [];
        this.draw();
    },
    
    addPoint: function(e) {
        const rect = this.ctx.canvas.getBoundingClientRect();
        this.points.push({x: e.clientX - rect.left, y: e.clientY - rect.top});
        this.draw();
    },
    
    clear: function() { this.points = []; this.draw(); },
    
    draw: function() {
        const w = this.ctx.canvas.width;
        const h = this.ctx.canvas.height;
        this.ctx.clearRect(0,0,w,h);
        drawGrid(this.ctx, w, h);
        
        // Draw Points
        this.ctx.fillStyle = getCSS('--text-main');
        this.points.forEach(p => drawCircle(this.ctx, p.x, p.y, 5));
        
        // Least Squares
        if(this.points.length >= 2) {
            let n = this.points.length;
            let sumX=0, sumY=0, sumXY=0, sumXX=0;
            for(let p of this.points) {
                sumX += p.x; sumY += p.y;
                sumXY += p.x*p.y; sumXX += p.x*p.x;
            }
            const slope = (n*sumXY - sumX*sumY) / (n*sumXX - sumX*sumX);
            const intercept = (sumY - slope*sumX) / n;
            
            this.ctx.strokeStyle = getCSS('--accent');
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.moveTo(0, intercept);
            this.ctx.lineTo(w, slope*w + intercept);
            this.ctx.stroke();
        }
    }
};

// --- Engine 4: KNN ---
const simKNN = {
    ctx: null,
    points: [], // {x, y, type: 0|1}
    
    init: function() {
        this.ctx = setupCanvas('cvs_knn');
        this.points = [];
        this.draw();
    },
    
    addPoint: function(e, type=0) {
        const rect = this.ctx.canvas.getBoundingClientRect();
        this.points.push({x: e.clientX - rect.left, y: e.clientY - rect.top, type: type});
        this.draw();
    },
    
    clear: function() { this.points = []; this.draw(); },
    
    draw: function() {
        const w = this.ctx.canvas.width;
        const h = this.ctx.canvas.height;
        this.ctx.clearRect(0,0,w,h);
        
        const k = parseInt(document.getElementById('knnK').value) || 3;
        const ca = getCSS('--accent'); // Class 0
        const cb = '#ef4444'; // Class 1 (Red)
        
        // Draw Decision Boundary (Low Res)
        if(this.points.length > 2) {
            const res = 10;
            for(let x=0; x<w; x+=res) {
                for(let y=0; y<h; y+=res) {
                    // Find K nearest
                    const dists = this.points.map(p => ({
                        d: (p.x-x)**2 + (p.y-y)**2,
                        type: p.type
                    })).sort((a,b) => a.d - b.d).slice(0, k);
                    
                    const count0 = dists.filter(d => d.type===0).length;
                    const color = count0 > k/2 ? ca : cb;
                    this.ctx.fillStyle = color;
                    this.ctx.globalAlpha = 0.1;
                    this.ctx.fillRect(x, y, res, res);
                }
            }
        }
        
        // Draw Points
        this.ctx.globalAlpha = 1.0;
        this.points.forEach(p => {
            this.ctx.fillStyle = p.type === 0 ? ca : cb;
            drawCircle(this.ctx, p.x, p.y, 6);
            this.ctx.strokeStyle = '#fff';
            this.ctx.stroke();
        });
    }
};

// --- Engine 5: K-Means ---
const simKMeans = {
    ctx: null,
    points: [], // {x, y, group}
    centroids: [], // {x, y, color}
    colors: ['#4f46e5', '#22c55e', '#ef4444'],
    
    init: function() {
        this.ctx = setupCanvas('cvs_kmeans');
        this.clear();
    },
    
    clear: function() {
        this.points = [];
        this.centroids = [];
        this.draw();
    },
    
    addPoint: function(e) {
        const rect = this.ctx.canvas.getBoundingClientRect();
        this.points.push({x: e.clientX - rect.left, y: e.clientY - rect.top, group: -1});
        this.draw();
    },
    
    step: function() {
        if(this.points.length === 0) return;
        
        // Init Centroids
        if(this.centroids.length === 0) {
            for(let i=0; i<3; i++) {
                // Randomly pick a point as centroid start
                if(this.points[i]) {
                    this.centroids.push({x: this.points[i].x, y: this.points[i].y});
                } else {
                    this.centroids.push({x: Math.random()*this.ctx.canvas.width, y: Math.random()*this.ctx.canvas.height});
                }
            }
        } else {
            // Move Centroids
            const sums = [
                {x:0, y:0, n:0}, {x:0, y:0, n:0}, {x:0, y:0, n:0}
            ];
            this.points.forEach(p => {
                if(p.group !== -1) {
                    sums[p.group].x += p.x;
                    sums[p.group].y += p.y;
                    sums[p.group].n++;
                }
            });
            this.centroids.forEach((c, i) => {
                if(sums[i].n > 0) {
                    c.x = sums[i].x / sums[i].n;
                    c.y = sums[i].y / sums[i].n;
                }
            });
        }
        
        // Assign Points
        this.points.forEach(p => {
            let minDist = Infinity;
            this.centroids.forEach((c, i) => {
                const d = (p.x-c.x)**2 + (p.y-c.y)**2;
                if(d < minDist) { minDist = d; p.group = i; }
            });
        });
        
        this.draw();
    },
    
    draw: function() {
        const w = this.ctx.canvas.width;
        const h = this.ctx.canvas.height;
        this.ctx.clearRect(0,0,w,h);
        
        // Points
        this.points.forEach(p => {
            this.ctx.fillStyle = p.group === -1 ? '#94a3b8' : this.colors[p.group];
            drawCircle(this.ctx, p.x, p.y, 5);
        });
        
        // Centroids
        this.centroids.forEach((c, i) => {
            this.ctx.fillStyle = this.colors[i];
            this.ctx.strokeStyle = '#000';
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.rect(c.x-8, c.y-8, 16, 16);
            this.ctx.fill();
            this.ctx.stroke();
        });
    }
};


// ==========================================
// 3. Helper Functions
// ==========================================
const router = {
    load: function(id) {
        const page = pages[id];
        document.querySelectorAll('.nav-item').forEach(el => el.classList.remove('active'));
        // Find element by onclick content (simplified)
        const els = document.querySelectorAll('.nav-item');
        for(let el of els) {
            if(el.getAttribute('onclick').includes(id)) el.classList.add('active');
        }
        
        document.getElementById('pageTitle').innerText = page.title;
        document.getElementById('app').innerHTML = page.content;
        
        if(window.MathJax) MathJax.typesetPromise();
        if(page.init) setTimeout(page.init, 50);
    }
};

function getCSS(varName) {
    return getComputedStyle(document.body).getPropertyValue(varName).trim();
}

function setupCanvas(id) {
    const cvs = document.getElementById(id);
    if(!cvs) return null;
    cvs.width = cvs.parentElement.clientWidth;
    cvs.height = cvs.parentElement.clientHeight;
    return cvs.getContext('2d');
}

function updateStatus(id, text, bgClass) {
    const el = document.getElementById(id);
    if(el) {
        el.innerText = text;
        el.className = `badge ${bgClass}`;
    }
}

function drawCircle(ctx, x, y, r) {
    ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
}

function drawGrid(ctx, w, h) {
    ctx.strokeStyle = getCSS('--chart-grid');
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(0, h-20); ctx.lineTo(w, h-20); // X-axis
    ctx.moveTo(20, 0); ctx.lineTo(20, h); // Y-axis
    ctx.stroke();
}

function drawChartLine(ctx, data, color, maxDataLen, w, h) {
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    data.forEach((val, i) => {
        const x = 20 + (i / maxDataLen) * (w-20);
        const y = h - 20 - (val / 150 * (h-40));
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    });
    ctx.stroke();
}

// Maps -10 to 10 coord space to canvas width
function mapX(x, w) { return (x + 10) / 20 * w; }
function mapY(y, h) { return h - (y + 10) / 100 * h; }

function toggleTheme() {
    const html = document.documentElement;
    const current = html.getAttribute('data-theme');
    html.setAttribute('data-theme', current === 'dark' ? 'light' : 'dark');
    
    // Re-render current page
    const active = document.querySelector('.nav-item.active');
    if(active) {
        const id = active.getAttribute('onclick').match(/'([^']+)'/)[1];
        if(pages[id].init) pages[id].init();
    }
}

// Boot
window.onload = () => router.load('concept_loss');
window.onresize = () => {
    // Resize handling simplified: reload current view logic
    const active = document.querySelector('.nav-item.active');
    if(active) {
         const id = active.getAttribute('onclick').match(/'([^']+)'/)[1];
         if(pages[id].init) pages[id].init();
    }
};

</script>
</body>
</html>
