<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Machine Learning Cookbook</title>
    <script>
    window.MathJax = {
      tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
      svg: { fontCache: 'global' },
      startup: { typeset: false }
    };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <style>
        :root {
            /* Light Mode */
            --bg-body: #f8fafc;
            --bg-sidebar: #ffffff;
            --bg-card: #ffffff;
            --text-main: #0f172a;
            --text-sub: #64748b;
            --accent: #4f46e5;
            --border: #e2e8f0;
            --chart-grid: #e2e8f0;
            --danger: #ef4444;
            --success: #22c55e;
            --warning: #f59e0b;
            --code-bg: #1e293b;
        }

        [data-theme="dark"] {
            --bg-body: #0f172a;
            --bg-sidebar: #1e293b;
            --bg-card: #1e293b;
            --text-main: #f1f5f9;
            --text-sub: #94a3b8;
            --accent: #38bdf8;
            --border: #334155;
            --chart-grid: #334155;
            --code-bg: #020617;
        }

        /* è°ƒæ•´bodyä¸ºå‚ç›´flexå¸ƒå±€ */
        body { 
            margin: 0; 
            font-family: 'Inter', system-ui, sans-serif; 
            background: var(--bg-body); 
            color: var(--text-main); 
            display: flex; 
            flex-direction: column; /* å‚ç›´æ’åˆ—å­å…ƒç´  */
            height: 100vh; 
            overflow: hidden; 
        }

        /* åŒ…è£¹navå’Œmainçš„å®¹å™¨ï¼Œå æ»¡ä¸­é—´ç©ºé—´ */
        .content-wrap {
            display: flex;
            flex: 1; /* å æ»¡bodyå‰©ä½™é«˜åº¦ */
            overflow: hidden;
        }

        /* Navigation */
        nav { 
            width: 260px; 
            background: var(--bg-sidebar); 
            border-right: 1px solid var(--border); 
            display: flex; 
            flex-direction: column; 
            flex-shrink: 0; 
        }
        .nav-header { padding: 20px; border-bottom: 1px solid var(--border); }
        .nav-header h1 { margin: 0; font-size: 1.2rem; color: var(--accent); font-weight: 800; }
        .nav-content { flex: 1; overflow-y: auto; padding-top: 10px; }
        
        .group-title { padding: 15px 20px 5px; font-size: 0.75rem; color: var(--text-sub); font-weight: bold; text-transform: uppercase; }
        .nav-item { padding: 10px 20px; cursor: pointer; color: var(--text-sub); font-size: 0.9rem; border-left: 3px solid transparent; transition: 0.2s; display: flex; align-items: center; gap: 8px; }
        .nav-item:hover { background: rgba(128,128,128,0.05); color: var(--text-main); }
        .nav-item.active { border-left-color: var(--accent); background: rgba(var(--accent), 0.1); color: var(--text-main); font-weight: 600; }

        /* Main Area */
        main { flex: 1; display: flex; flex-direction: column; overflow-y: auto; }
        .header { padding: 15px 30px; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; background: var(--bg-body); position: sticky; top: 0; z-index: 10; }
        
        .container { padding: 30px; max-width: 1200px; margin: 0 auto; width: 100%; box-sizing: border-box; }

        /* UI Elements */
        .card { background: var(--bg-card); border: 1px solid var(--border); border-radius: 12px; padding: 20px; margin-bottom: 20px; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.02); }
        
        .canvas-box { background: var(--bg-body); border: 1px solid var(--border); border-radius: 8px; position: relative; overflow: hidden; cursor: crosshair; }
        canvas { display: block; width: 100%; height: 100%; }

        .controls { display: flex; gap: 15px; flex-wrap: wrap; margin-bottom: 15px; align-items: center; background: rgba(128,128,128,0.03); padding: 10px; border-radius: 8px; }
        button { padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: 600; border: none; transition: 0.2s; }
        .btn-primary { background: var(--accent); color: white; }
        .btn-outline { background: transparent; border: 1px solid var(--border); color: var(--text-main); }
        .btn-outline:hover { background: rgba(128,128,128,0.05); }

        .math-box { background: rgba(128,128,128,0.05); padding: 15px; border-radius: 6px; border-left: 4px solid var(--accent); margin: 15px 0; overflow-x: auto; font-size: 0.95rem; }
        .badge { padding: 4px 10px; border-radius: 4px; font-size: 0.8rem; font-weight: bold; }
        .legend { display: flex; gap: 15px; font-size: 0.85rem; color: var(--text-sub); margin-bottom: 5px; }
        .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; margin-right: 5px; }

        .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        @media(max-width:900px){ .grid-2 { grid-template-columns: 1fr; } }
        
        /* é¡µè„šæ ·å¼ï¼šå·¦å¯¹é½ã€åº•éƒ¨å·¦ä¸‹è§’ */
        .footer {
            text-align: left; /* å·¦å¯¹é½ */
            padding: 1rem 2rem; /* å†…è¾¹è·é€‚é… */
            color: var(--text-sub); /* è·Ÿéšä¸»é¢˜æ–‡æœ¬é¢œè‰² */
            font-size: 0.9rem;
            border-top: 1px solid var(--border); /* è·Ÿéšä¸»é¢˜è¾¹æ¡†è‰² */
            background: var(--bg-body); /* è·Ÿéšä¸»é¢˜èƒŒæ™¯ */
        }
    </style>
</head>
<body>
    <!-- åŒ…è£¹å¯¼èˆªå’Œä¸»å†…å®¹çš„å®¹å™¨ -->
    <div class="content-wrap">
        <nav>
            <div class="nav-header">
                <h1>ğŸ³ ML Cookbook</h1>
            </div>
            <div class="nav-content">
                <div class="group-title">æ ¸å¿ƒåŸç† (Theory)</div>
                <div class="nav-item active" onclick="router.load('theory_loss')">ğŸ“‰ Loss & è¿‡æ‹Ÿåˆæ¼”ç¤º</div>
                <div class="nav-item" onclick="router.load('theory_reg')">ğŸ›¡ï¸ æ­£åˆ™åŒ–ä¸å¤æ‚åº¦</div>

                <div class="group-title">å›å½’ (Regression)</div>
                <div class="nav-item" onclick="router.load('reg_linear')">ğŸ“ ç®€å•çº¿æ€§å›å½’</div>
                <div class="nav-item" onclick="router.load('reg_poly')">ğŸ¢ å¤–æ¨ç¾éš¾ (Extrapolation)</div>
                <div class="nav-item" onclick="router.load('reg_vs')">âš”ï¸ çº¿æ€§ vs éçº¿æ€§</div>

                <div class="group-title">åˆ†ç±» (Classification)</div>
                <div class="nav-item" onclick="router.load('cls_logistic')">ğŸš€ é€»è¾‘å›å½’ (æ¢¯åº¦ä¸‹é™)</div>
                <div class="nav-item" onclick="router.load('cls_knn')">ğŸ”´ KNN (K=2)</div>

                <div class="group-title">èšç±» (Clustering)</div>
                <div class="nav-item" onclick="router.load('clu_kmeans')">ğŸ§© K-Means</div>
            </div>
        </nav>

        <main>
            <div class="header">
                <h2 id="pageTitle" style="margin:0; font-size:1.1rem;"></h2>
                <button class="btn-outline" onclick="toggleTheme()">ğŸŒ— åˆ‡æ¢æ¨¡å¼</button>
            </div>
            <div id="app" class="container"></div>
        </main>
    </div>

    <!-- é¡µè„šï¼šä½äºé¡µé¢åº•éƒ¨å·¦ä¸‹è§’ -->
    <footer class="footer">
        ç”± Karcen Zheng åˆ¶ä½œï¼Œ<a href="https://karcen.github.io/zhengjiacheng.github.io/" target="_blank">è”ç³»æˆ‘</a>
    </footer>

<script>
// ==========================================
// 1. é¡µé¢å†…å®¹
// ==========================================
const pages = {
    // --- 1. Loss Animation ---
    'theory_loss': {
        title: 'åŸç†æ¼”ç¤ºï¼šLoss æ›²çº¿ä¸è¿‡æ‹Ÿåˆ',
        content: `
            <div class="card">
                <p>ç‚¹å‡»å¼€å§‹ï¼Œè§‚å¯Ÿ <b>Train Loss (ç»¿çº¿)</b> å’Œ <b>Val Loss (çº¢çº¿)</b>ã€‚æ³¨æ„çº¢çº¿åœ¨åæœŸå¦‚ä½•<b>åå¼¹</b>ï¼ˆè¿‡æ‹Ÿåˆï¼‰ã€‚</p>
                <div class="controls">
                    <button class="btn-primary" onclick="simLoss.start()">â–¶ å¼€å§‹æ¼”ç¤º</button>
                    <button class="btn-outline" onclick="simLoss.reset()">ğŸ”„ é‡ç½®</button>
                    <span id="loss_badge" class="badge" style="margin-left:auto; background:#f1f5f9; color:#64748b">Epoch: 0</span>
                </div>
                <div class="grid-2">
                    <div>
                        <div class="legend"><span><span class="dot" style="background:var(--text-main)"></span>æ•°æ®ç‚¹</span><span><span class="dot" style="background:var(--accent)"></span>æ‹Ÿåˆæ›²çº¿</span></div>
                        <div class="canvas-box" style="height:300px"><canvas id="cvs_loss_fit"></canvas></div>
                    </div>
                    <div>
                        <div class="legend"><span><span class="dot" style="background:var(--success)"></span>Train Loss</span><span><span class="dot" style="background:var(--danger)"></span>Val Loss</span></div>
                        <div class="canvas-box" style="height:300px"><canvas id="cvs_loss_chart"></canvas></div>
                    </div>
                </div>
            </div>
            <div class="math-box">
                <b>Scale Note:</b> Loss èŒƒå›´ 0~100ã€‚Yè½´è‡ªåŠ¨ç¼©æ”¾ä»¥é€‚åº”æ­¤èŒƒå›´ã€‚
            </div>
        `,
        init: () => simLoss.init()
    },

    // --- 2. Regularization ---
    'theory_reg': {
        title: 'åŸç†å®éªŒï¼šæ­£åˆ™åŒ– (Regularization)',
        content: `
            <div class="card">
                <p>è°ƒèŠ‚ <b>Lambda</b>ï¼Œçœ‹å®ƒæ˜¯å¦‚ä½•æƒ©ç½šæ¨¡å‹çš„å¤æ‚åº¦ï¼ŒæŠŠæ›²çº¿â€œæ‹‰ç›´â€çš„ã€‚</p>
                <div class="controls">
                    <div style="flex:1"><label>å¤šé¡¹å¼æ¬¡æ•°: <input type="range" id="regDeg" min="1" max="15" value="12" oninput="simReg.update()"></label></div>
                    <div style="flex:1"><label>Lambda ($\lambda$): <input type="range" id="regLam" min="0" max="100" value="0" oninput="simReg.update()"></label> <b id="lamVal" style="color:var(--accent)">0</b></div>
                    <button class="btn-outline" onclick="simReg.gen()">ğŸ² æ–°æ•°æ®</button>
                </div>
                <div class="canvas-box" style="height:400px"><canvas id="cvs_reg"></canvas></div>
            </div>
        `,
        init: () => simReg.init()
    },

    // --- 3. Linear Regression ---
    'reg_linear': {
        title: 'å®éªŒå®¤ï¼šç®€å•çº¿æ€§å›å½’',
        content: `
            <div class="card">
                <div class="controls">
                    <span>ç‚¹å‡»ç”»å¸ƒæ·»åŠ æ•°æ®ç‚¹ã€‚</span>
                    <button class="btn-outline" style="margin-left:auto" onclick="engLinear.reset()">ğŸ—‘ï¸ æ¸…ç©º</button>
                </div>
                <div class="canvas-box" style="height:400px" onmousedown="engLinear.add(event)"><canvas id="cvs_linear"></canvas></div>
            </div>
        `,
        init: () => engLinear.init()
    },

    // --- 4. Poly Extrapolation ---
    'reg_poly': {
        title: 'å®éªŒå®¤ï¼šå¤–æ¨ç¾éš¾ (Extrapolation)',
        content: `
            <div class="card">
                <p>è§‚å¯Ÿ<b>é˜´å½±åŒºåŸŸï¼ˆæœªçŸ¥åŒºï¼‰</b>ã€‚å½“ Degree å¾ˆé«˜æ—¶ï¼Œæ¨¡å‹åœ¨è®­ç»ƒåŒºå¾ˆå®Œç¾ï¼Œä½†åœ¨å¤–æ¨åŒºå®Œå…¨å´©æºƒã€‚</p>
                <div class="controls">
                    <label>Degree: <b id="polyDegDisp" style="color:var(--accent)">1</b></label>
                    <input type="range" id="polyDeg" min="1" max="15" value="1" style="flex:1" oninput="engPoly.update()">
                    <button class="btn-outline" onclick="engPoly.gen()">ğŸ² é‡ç”Ÿæˆ</button>
                </div>
                <div class="canvas-box" style="height:400px"><canvas id="cvs_poly"></canvas></div>
            </div>
        `,
        init: () => engPoly.init()
    },

    // --- 5. Linear vs Non-Linear ---
    'reg_vs': {
        title: 'å®éªŒå®¤ï¼šçº¿æ€§ vs éçº¿æ€§',
        content: `
            <div class="card">
                <div class="controls">
                    <span>ç”»ä¸€ä¸ª <b>Uå‹</b> æˆ– <b>Så‹</b> æ•°æ®åˆ†å¸ƒã€‚</span>
                    <button class="btn-outline" style="margin-left:auto" onclick="engVs.reset()">æ¸…ç©º</button>
                </div>
                <div class="legend"><span><span class="dot" style="background:var(--danger)"></span>çº¿æ€§</span><span><span class="dot" style="background:var(--success)"></span>å¤šé¡¹å¼ (Deg=4)</span></div>
                <div class="canvas-box" style="height:400px" onmousedown="engVs.add(event)"><canvas id="cvs_vs"></canvas></div>
            </div>
        `,
        init: () => engVs.init()
    },

    // --- 6. Logistic ---
    'cls_logistic': {
        title: 'å®éªŒå®¤ï¼šé€»è¾‘å›å½’ (è®­ç»ƒè¿‡ç¨‹)',
        content: `
            <div class="card">
                <div class="controls">
                    <span>å·¦é”®åŠ <b>Aç±»</b>ï¼Œå³é”®åŠ <b>Bç±»</b>ã€‚</span>
                    <button class="btn-primary" style="margin-left:auto" onclick="engLog.toggle()" id="btn_log">â–¶ å¼€å§‹è®­ç»ƒ</button>
                    <button class="btn-outline" onclick="engLog.reset()">ğŸ—‘ï¸ æ¸…ç©º</button>
                </div>
                <div class="grid-2">
                    <div>
                        <div class="legend"><span><span class="dot" style="background:var(--accent)"></span>Aç±»</span><span><span class="dot" style="background:var(--danger)"></span>Bç±»</span></div>
                        <div class="canvas-box" style="height:350px" onmousedown="engLog.add(event)" oncontextmenu="event.preventDefault(); engLog.add(event, 1)"><canvas id="cvs_log_main"></canvas></div>
                    </div>
                    <div>
                        <div class="legend"><span><span class="dot" style="background:var(--warning)"></span>Loss (äº¤å‰ç†µ)</span></div>
                        <div class="canvas-box" style="height:350px"><canvas id="cvs_log_loss"></canvas></div>
                    </div>
                </div>
                <p style="font-size:0.8rem; margin-top:5px; color:var(--text-sub)">å³ä¾§ Loss èŒƒå›´ï¼š0.0 ~ 1.0</p>
            </div>
        `,
        init: () => engLog.init()
    },

    // --- 7. KNN ---
    'cls_knn': {
        title: 'å®éªŒå®¤ï¼šKNN (K=2)',
        content: `
            <div class="card">
                <div class="controls">
                    <span>å·¦é”®çº¢ç‚¹ï¼Œå³é”®è“ç‚¹ã€‚</span>
                    <label style="margin-left:auto">Kå€¼: <input type="number" id="knnK" value="2" min="1" max="9" style="width:50px" onchange="engKNN.draw()"></label>
                    <button class="btn-outline" onclick="engKNN.reset()">æ¸…ç©º</button>
                </div>
                <div class="canvas-box" style="height:450px" onmousedown="engKNN.add(event)" oncontextmenu="event.preventDefault(); engKNN.add(event, 1)"><canvas id="cvs_knn"></canvas></div>
            </div>
        `,
        init: () => engKNN.init()
    },

    // --- 8. KMeans ---
    'clu_kmeans': {
        title: 'å®éªŒå®¤ï¼šK-Means',
        content: `
            <div class="card">
                <div class="controls">
                    <span>1. ç‚¹å‡»åŠ ç‚¹ &nbsp; 2. ç‚¹å‡»è¿­ä»£</span>
                    <button class="btn-primary" style="margin-left:auto" onclick="engKMeans.step()">ğŸ‘£ è¿­ä»£ä¸€æ­¥</button>
                    <button class="btn-outline" onclick="engKMeans.reset()">ğŸ—‘ï¸ é‡ç½®</button>
                </div>
                <div class="canvas-box" style="height:400px" onmousedown="engKMeans.add(event)"><canvas id="cvs_kmeans"></canvas></div>
            </div>
        `,
        init: () => engKMeans.init()
    }
};

// ==========================================
// 2. å¼•æ“æ ¸å¿ƒ (Engines)
// ==========================================

// --- Theory: Loss Animation (Fix: Proper Scaling) ---
const simLoss = {
    ep:0, timer:null, tL:[], vL:[], pts:[], ctxF:null, ctxL:null,
    init: function() { this.ctxF=getCtx('cvs_loss_fit'); this.ctxL=getCtx('cvs_loss_chart'); this.reset(); },
    reset: function() {
        clearInterval(this.timer); this.timer=null; this.ep=0; this.tL=[]; this.vL=[];
        this.pts=[]; for(let x=-10;x<=10;x+=1.5) this.pts.push({x, y:0.3*x*x+(Math.random()-0.5)*30});
        updateTxt('loss_badge', 'Epoch: 0'); 
        if(this.ctxF) this.draw();
    },
    start: function() { if(!this.timer) this.timer=setInterval(()=>this.step(), 100); },
    step: function() {
        if(this.ep++ > 60) { clearInterval(this.timer); this.timer=null; return; }
        
        // Sim Logic: Start high (~80), drop to ~10 (Train), ~40 (Val)
        const base = Math.exp(-this.ep*0.1)*80;
        let tl=base+Math.random()*2, vl=base+15+Math.random()*5;
        if(this.ep>25) { tl-=(this.ep-25)*0.5; vl+=(this.ep-25)*1.5; } // Overfit split
        
        this.tL.push(Math.max(0,tl)); this.vL.push(Math.max(0,vl));
        updateTxt('loss_badge', `Epoch: ${this.ep}`); this.draw();
    },
    draw: function() {
        const w=this.ctxF.canvas.width, h=this.ctxF.canvas.height;
        this.ctxF.clearRect(0,0,w,h);
        // Draw Points
        this.ctxF.fillStyle=getVar('--text-main'); 
        this.pts.forEach(p=>circle(this.ctxF, map(p.x,-10,10,0,w), map(p.y,-50,150,h,0), 4));
        // Draw Curve
        this.ctxF.strokeStyle=getVar('--accent'); this.ctxF.lineWidth=3; this.ctxF.beginPath();
        for(let x=-10;x<=10;x+=0.5) {
            let y = this.ep<5?40:(this.ep<25?0.3*x*x : 0.3*x*x+Math.sin(x*2+this.ep)*12*(this.ep-20)/40);
            const px=map(x,-10,10,0,w), py=map(y,-50,150,h,0); if(x===-10) this.ctxF.moveTo(px,py); else this.ctxF.lineTo(px,py);
        }
        this.ctxF.stroke();
        
        // Draw Loss Chart
        const cL=this.ctxL; cL.clearRect(0,0,w,h); drawGrid(cL,w,h);
        lineChart(cL, this.tL, getVar('--success'), 120); 
        lineChart(cL, this.vL, getVar('--danger'), 120);
    }
};

// --- Theory: Regularization ---
const simReg = {
    ctx:null, pts:[],
    init: function() { this.ctx=getCtx('cvs_reg'); this.gen(); },
    gen: function() { this.pts=[]; for(let i=0;i<15;i++) this.pts.push({x:i/14, y:0.5+(Math.random()-0.5)*0.4}); this.update(); },
    update: function() {
        if(!this.ctx) return;
        const w=this.ctx.canvas.width, h=this.ctx.canvas.height;
        const deg=parseInt(document.getElementById('regDeg').value), lam=parseInt(document.getElementById('regLam').value);
        document.getElementById('lamVal').innerText = lam;
        
        this.ctx.clearRect(0,0,w,h); drawGrid(this.ctx,w,h);
        this.ctx.fillStyle=getVar('--text-main'); this.pts.forEach(p=>circle(this.ctx, p.x*w, h-p.y*h, 5));
        
        const pred = Matrix.solveReg(this.pts, deg, lam/20);
        if(pred) {
            this.ctx.strokeStyle = lam>50 ? getVar('--success') : (lam>10?getVar('--accent'):getVar('--danger'));
            this.ctx.lineWidth=3; this.ctx.beginPath();
            for(let x=0; x<=1; x+=0.01) { const y=pred(x); if(x===0) this.ctx.moveTo(x*w,h-y*h); else this.ctx.lineTo(x*w,h-y*h); }
            this.ctx.stroke();
        }
    }
};

// --- Regression: Simple ---
const engLinear = {
    ctx:null, pts:[],
    init: function() { this.ctx=getCtx('cvs_linear'); this.reset(); },
    reset: function() { this.pts=[]; this.draw(); },
    add: function(e) { const r=this.ctx.canvas.getBoundingClientRect(); this.pts.push({x:e.clientX-r.left, y:e.clientY-r.top}); this.draw(); },
    draw: function() {
        const w=this.ctx.canvas.width, h=this.ctx.canvas.height;
        this.ctx.clearRect(0,0,w,h); drawGrid(this.ctx,w,h);
        this.ctx.fillStyle=getVar('--text-main'); this.pts.forEach(p=>circle(this.ctx, p.x, p.y, 5));
        if(this.pts.length>1) {
            const pred = Matrix.solveReg(this.pts, 1, 0);
            this.ctx.strokeStyle=getVar('--accent'); this.ctx.lineWidth=2; this.ctx.beginPath();
            this.ctx.moveTo(0, pred(0)); this.ctx.lineTo(w, pred(w)); this.ctx.stroke();
        }
    }
};

// --- Regression: Extrapolation ---
const engPoly = {
    ctx:null, tr:[], te:[],
    init: function() { this.ctx=getCtx('cvs_poly'); this.gen(); },
    gen: function() {
        this.tr=[]; this.te=[]; const f=x=>0.4*x*x-0.1*x*x*x;
        for(let i=0;i<15;i++) { let x=Math.random()*2-1; this.tr.push({x, y:f(x)+(Math.random()-0.5)*0.3}); }
        this.update();
    },
    update: function() {
        if(!this.ctx) return;
        const deg=parseInt(document.getElementById('polyDeg').value);
        updateTxt('polyDegDisp', deg);
        const w=this.ctx.canvas.width, h=this.ctx.canvas.height;
        this.ctx.clearRect(0,0,w,h);
        
        // Zones
        this.ctx.fillStyle=getVar('--bg-body')==='#f8fafc'?'#f1f5f9':'#1e293b'; this.ctx.fillRect(0,0,w,h);
        this.ctx.fillStyle=getVar('--bg-card'); this.ctx.fillRect(w*0.25,0,w*0.5,h);
        drawGrid(this.ctx,w,h);

        const pred = Matrix.solveReg(this.tr, deg, 0);
        if(pred) {
            this.ctx.strokeStyle=getVar('--accent'); this.ctx.lineWidth=3; this.ctx.beginPath();
            let start=false;
            for(let px=0; px<=w; px+=2) {
                const mx=map(px,0,w,-2,2), my=pred(mx), py=map(my,-2,3,h,0);
                if(py<-100||py>h+100){start=false;continue;}
                if(!start){this.ctx.moveTo(px,py);start=true;}else this.ctx.lineTo(px,py);
            }
            this.ctx.stroke();
        }
        
        const mx=x=>map(x,-2,2,0,w), my=y=>map(y,-2,3,h,0);
        this.tr.forEach(p=>{this.ctx.fillStyle=getVar('--text-main'); circle(this.ctx, mx(p.x), my(p.y), 4);});
        
        this.ctx.strokeStyle='#94a3b8'; this.ctx.setLineDash([5,5]);
        this.ctx.beginPath(); this.ctx.moveTo(w*0.25,0); this.ctx.lineTo(w*0.25,h); this.ctx.stroke();
        this.ctx.beginPath(); this.ctx.moveTo(w*0.75,0); this.ctx.lineTo(w*0.75,h); this.ctx.stroke();
        this.ctx.setLineDash([]);
    }
};

// --- Linear vs Non-Linear ---
const engVs = {
    ctx:null, pts:[],
    init: function() { this.ctx=getCtx('cvs_vs'); this.reset(); },
    reset: function() { this.pts=[]; this.draw(); },
    add: function(e) { const r=this.ctx.canvas.getBoundingClientRect(); this.pts.push({x:e.clientX-r.left, y:e.clientY-r.top}); this.draw(); },
    draw: function() {
        const w=this.ctx.canvas.width, h=this.ctx.canvas.height;
        this.ctx.clearRect(0,0,w,h); drawGrid(this.ctx,w,h);
        this.ctx.fillStyle=getVar('--text-main'); this.pts.forEach(p=>circle(this.ctx, p.x, p.y, 5));
        if(this.pts.length<2) return;
        const p1=Matrix.solveReg(this.pts, 1);
        if(p1){this.ctx.strokeStyle=getVar('--danger');this.ctx.lineWidth=3;this.ctx.beginPath();this.ctx.moveTo(0,p1(0));this.ctx.lineTo(w,p1(w));this.ctx.stroke();}
        const p4=Matrix.solveReg(this.pts, 4);
        if(p4){this.ctx.strokeStyle=getVar('--success');this.ctx.lineWidth=3;this.ctx.beginPath();for(let x=0;x<=w;x+=5){let y=p4(x);if(x===0)this.ctx.moveTo(x,y);else this.ctx.lineTo(x,y);}this.ctx.stroke();}
    }
};

// --- Logistic ---
const engLog = {
    ctxM:null, ctxL:null, pts:[], w:{w1:0,w2:0,b:0}, ls:[], tm:null, tr:false,
    init: function() { this.ctxM=getCtx('cvs_log_main'); this.ctxL=getCtx('cvs_log_loss'); this.reset(); },
    reset: function() { 
        this.pts=[]; this.ls=[]; this.tr=false; clearInterval(this.tm); 
        this.w={w1:Math.random()-0.5,w2:Math.random()-0.5,b:0}; updateTxt('btn_log','â–¶ å¼€å§‹è®­ç»ƒ'); this.draw(); 
    },
    add: function(e,t=0) { const r=this.ctxM.canvas.getBoundingClientRect(); this.pts.push({x:(e.clientX-r.left)/r.width*2-1, y:-((e.clientY-r.top)/r.height*2-1), t}); this.draw(); },
    toggle: function() { if(this.tr){this.tr=false;clearInterval(this.tm);updateTxt('btn_log','â–¶ ç»§ç»­');}else{this.tr=true;this.tm=setInterval(()=>this.step(),20);updateTxt('btn_log','â¸ æš‚åœ');} },
    step: function() {
        if(!this.pts.length) return;
        let dw1=0,dw2=0,db=0,loss=0,N=this.pts.length;
        this.pts.forEach(p=>{
            const z=this.w.w1*p.x+this.w.w2*p.y+this.w.b, a=1/(1+Math.exp(-z));
            loss+=-(p.t*Math.log(Math.max(1e-4,a))+(1-p.t)*Math.log(Math.max(1e-4,1-a)));
            const d=a-p.t; dw1+=p.x*d; dw2+=p.y*d; db+=d;
        });
        const lr=0.05; this.w.w1-=lr*dw1/N; this.w.w2-=lr*dw2/N; this.w.b-=lr*db/N;
        this.ls.push(loss/N); if(this.ls.length>200)this.ls.shift();
        this.draw();
    },
    draw: function() {
        const w=this.ctxM.canvas.width, h=this.ctxM.canvas.height;
        this.ctxM.clearRect(0,0,w,h);
        if(this.pts.length) {
            const img=this.ctxM.createImageData(w,h), {w1,w2,b}=this.w;
            for(let py=0;py<h;py+=5)for(let px=0;px<w;px+=5) {
                const a=1/(1+Math.exp(-(w1*(px/w*2-1)+w2*(-(py/h*2-1))+b)));
                const c=a<0.5?0:1, alp=Math.abs(a-0.5)*150;
                for(let dy=0;dy<5;dy++)for(let dx=0;dx<5;dx++){const i=((py+dy)*w+(px+dx))*4; img.data[i]=c?239:56;img.data[i+1]=c?68:189;img.data[i+2]=c?68:248;img.data[i+3]=alp;}
            }
            this.ctxM.putImageData(img,0,0);
        }
        this.pts.forEach(p=>{this.ctxM.fillStyle=p.t===0?getVar('--accent'):'#ef4444'; circle(this.ctxM,(p.x+1)/2*w,(-p.y+1)/2*h,6); this.ctxM.strokeStyle='#fff';this.ctxM.stroke();});
        
        // Draw Loss (Max scale 1.0 for Log Loss)
        const cL=this.ctxL; cL.clearRect(0,0,w,h); drawGrid(cL,w,h); 
        lineChart(cL,this.ls,getVar('--warning'), 1.0); 
    }
};

// --- KNN ---
const engKNN = {
    ctx:null, pts:[],
    init: function() { this.ctx=getCtx('cvs_knn'); this.reset(); },
    reset: function() { this.pts=[]; this.draw(); },
    add: function(e,t=0) { const r=this.ctx.canvas.getBoundingClientRect(); this.pts.push({x:e.clientX-r.left, y:e.clientY-r.top, t}); this.draw(); },
    draw: function() {
        const w=this.ctx.canvas.width, h=this.ctx.canvas.height, K=parseInt(document.getElementById('knnK').value);
        this.ctx.clearRect(0,0,w,h);
        if(this.pts.length>0) {
            for(let x=0;x<w;x+=10)for(let y=0;y<h;y+=10) {
                const ds=this.pts.map(p=>({d:(p.x-x)**2+(p.y-y)**2, t:p.t})).sort((a,b)=>a.d-b.d).slice(0,K);
                const c0=ds.filter(d=>d.t===0).length;
                this.ctx.fillStyle=c0>K/2?getVar('--accent'):'#ef4444'; this.ctx.globalAlpha=0.2; this.ctx.fillRect(x,y,10,10);
            }
        }
        this.ctx.globalAlpha=1; this.pts.forEach(p=>{this.ctx.fillStyle=p.t===0?getVar('--accent'):'#ef4444'; circle(this.ctx,p.x,p.y,6); this.ctx.strokeStyle='#fff';this.ctx.stroke();});
    }
};

// --- KMeans ---
const engKMeans = {
    ctx:null, pts:[], cens:[], cols:['#f59e0b','#22c55e','#ef4444'],
    init: function() { this.ctx=getCtx('cvs_kmeans'); this.reset(); },
    reset: function() { this.pts=[]; this.cens=[]; this.draw(); },
    add: function(e) { const r=this.ctx.canvas.getBoundingClientRect(); this.pts.push({x:e.clientX-r.left, y:e.clientY-r.top, g:-1}); this.draw(); },
    step: function() {
        if(!this.pts.length) return;
        if(!this.cens.length) for(let i=0;i<3;i++) this.cens.push(this.pts[Math.floor(Math.random()*this.pts.length)] || {x:Math.random()*300,y:Math.random()*300});
        else {
            const sums=[{x:0,y:0,n:0},{x:0,y:0,n:0},{x:0,y:0,n:0}];
            this.pts.forEach(p=>{if(p.g!==-1){sums[p.g].x+=p.x;sums[p.g].y+=p.y;sums[p.g].n++;}});
            this.cens.forEach((c,i)=>{if(sums[i].n){c.x=sums[i].x/sums[i].n;c.y=sums[i].y/sums[i].n;}});
        }
        this.pts.forEach(p=>{ let min=Infinity; this.cens.forEach((c,i)=>{const d=(p.x-c.x)**2+(p.y-c.y)**2;if(d<min){min=d;p.g=i;}}); });
        this.draw();
    },
    draw: function() {
        const w=this.ctx.canvas.width, h=this.ctx.canvas.height;
        this.ctx.clearRect(0,0,w,h);
        this.pts.forEach(p=>{this.ctx.fillStyle=p.g===-1?getVar('--text-sub'):this.cols[p.g]; circle(this.ctx,p.x,p.y,5);});
        this.cens.forEach((c,i)=>{this.ctx.fillStyle=this.cols[i];this.ctx.strokeStyle='#000';this.ctx.lineWidth=2;this.ctx.beginPath();this.ctx.rect(c.x-8,c.y-8,16,16);this.ctx.fill();this.ctx.stroke();});
    }
};

// ==========================================
// Utils & Matrix
// ==========================================
const Matrix = {
    transpose: A => A[0].map((_, c) => A.map(r => r[c])),
    multiply: (A, B) => {
        const m=A.length, n=A[0].length, p=B[0].length, R=Array(m).fill(0).map(()=>Array(p).fill(0));
        for(let i=0;i<m;i++) for(let j=0;j<p;j++) for(let k=0;k<n;k++) R[i][j]+=A[i][k]*B[k][j];
        return R;
    },
    inverse: (A) => {
        const n=A.length, M=A.map((r,i)=>[...r, ...Array(n).fill(0).map((_,j)=>i===j?1:0)]);
        for(let i=0;i<n;i++) {
            let p=M[i][i]; if(Math.abs(p)<1e-9) p=1e-9;
            for(let j=0;j<2*n;j++) M[i][j]/=p;
            for(let k=0;k<n;k++) if(k!==i) { const f=M[k][i]; for(let j=0;j<2*n;j++) M[k][j]-=f*M[i][j]; }
        }
        return M.map(r=>r.slice(n));
    },
    solveReg: (pts, deg, lambda=0) => {
        if(pts.length < 2) return null;
        const xs=pts.map(p=>p.x), minX=Math.min(...xs), maxX=Math.max(...xs), rng=maxX-minX||1;
        const X = pts.map(p => { const nx=(p.x-minX)/rng*2-1; return Array(deg+1).fill(0).map((_,i)=>Math.pow(nx,i)); });
        const Y = pts.map(p => [p.y]);
        try {
            const XT = Matrix.transpose(X);
            let XTX = Matrix.multiply(XT, X);
            if(lambda>0) for(let i=0;i<=deg;i++) XTX[i][i]+=lambda;
            const W = Matrix.multiply(Matrix.multiply(Matrix.inverse(XTX), XT), Y);
            return x => { const nx=(x-minX)/rng*2-1; return W.reduce((s,w,i)=>s+w[0]*Math.pow(nx,i),0); };
        } catch(e) { return null; }
    }
};

function getCtx(id) { const c=document.getElementById(id); return c? (c.width=c.parentElement.clientWidth, c.height=c.parentElement.clientHeight, c.getContext('2d')) : null; }
function getVar(n) { return getComputedStyle(document.body).getPropertyValue(n).trim(); }
function circle(ctx,x,y,r) { ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); }
function map(v,i1,i2,o1,o2) { return o1 + (o2-o1)*((v-i1)/(i2-i1)); }
function updateTxt(id,t) { document.getElementById(id).innerText=t; }
function drawGrid(c,w,h) { c.strokeStyle=getVar('--chart-grid'); c.lineWidth=1; c.beginPath(); c.moveTo(0,h-20); c.lineTo(w,h-20); c.stroke(); }
function lineChart(c,d,col,maxScale) {
    if(!d.length)return; 
    c.strokeStyle=col; c.lineWidth=2; c.beginPath(); 
    d.forEach((v,i)=>{
        const x=i/d.length*c.canvas.width;
        // Fix Scaling: use maxScale as the ceiling
        const y=c.canvas.height-20 - (v / maxScale * (c.canvas.height-40));
        if(i===0)c.moveTo(x,y);else c.lineTo(x,y);
    }); 
    c.stroke(); 
}

const router = {
    load: function(id) {
        document.querySelectorAll('.nav-item').forEach(e=>e.classList.remove('active'));
        const active=Array.from(document.querySelectorAll('.nav-item')).find(e=>e.getAttribute('onclick').includes(id));
        if(active) active.classList.add('active');
        document.getElementById('pageTitle').innerText = pages[id].title;
        document.getElementById('app').innerHTML = pages[id].content;
        if(pages[id].init) setTimeout(pages[id].init, 50);
        if(window.MathJax) MathJax.typesetPromise();
    }
};

function toggleTheme() {
    const h=document.documentElement; h.setAttribute('data-theme', h.getAttribute('data-theme')==='dark'?'light':'dark');
    const id=document.querySelector('.nav-item.active').getAttribute('onclick').match(/'([^']+)'/)[1];
    if(pages[id].init) pages[id].init();
}

window.onload = () => router.load('theory_loss');
window.onresize = () => { const id=document.querySelector('.nav-item.active').getAttribute('onclick').match(/'([^']+)'/)[1]; if(pages[id].init) pages[id].init(); };

</script>
</body>
</html>
